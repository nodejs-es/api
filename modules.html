<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>modules - Node.js Manual &amp; Documentación</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all"/>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js Manual &amp; Documentación</h1>
      <div id="gtoc">
        <p><a href="index.html">Inicio</a> | <a href="all.html">Ver en una página</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Tabla de contenidos</h2><ul><li><a href="#m_dulos">Módulos</a><ul><li><a href="#m_dulos_b_sicos">Módulos básicos</a></li><li><a href="#m_dulo_File">Módulo File</a></li><li><a href="#cargando_desde_la_carpeta_node_modules_">Cargando desde la carpeta `node_modules`</a><ul><li><a href="#optimizaci_n_de_proceso_de_b_squeda_en_node_modules_">Optimización de proceso de búsqueda en `node_modules`</a></li></ul></li><li><a href="#carpetas_como_m_dulos">Carpetas como módulos</a></li><li><a href="#almacenamiento_en_la_cach_">Almacenamiento en la caché</a></li><li><a href="#todos_juntos...">Todos juntos...</a></li><li><a href="#cargar_desde_las_carpetas_de_require.paths_">Cargar desde las carpetas de `require.paths`</a><ul><li><a href="#nota_Por_favor_evite_la_modificaci_n_de_require.paths_">Nota:** Por favor evite la modificación de `require.paths`</a><ul><li><a href="#establecer_require.paths_a_alg_n_otro_valor_para_nada.">Establecer `require.paths` a algún otro valor para nada.</a></li><li><a href="#poner_rutas_relativas_en_require.paths_es..._raro.">Poner rutas relativas en `require.paths` es... raro.</a></li><li><a href="#cero_aislamiento">Cero aislamiento</a></li></ul></li></ul></li></ul></li><li><a href="#addenda_Consejos_para_administrar_paquetes">Addenda: Consejos para administrar paquetes</a></li></ul><hr /></div>
<h2 id="m_dulos">Módulos</h2>

<p>Node posee un secillo sistema de carga.  En Node, los ficheros y módulos son de
correspondencia biunívoca.  A modo de ejemplo, <code>foo.js</code> carga el módulo
<code>circle.js</code> en el mismo directorio.</p>

<p>El contenido de <code>foo.js</code>:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'El área de un círculo con radio 4 es '
           + circle.area(4));</code></pre>

<p>El contenido de <code>circle.js</code>:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>

<p>El módulo <code>circle.js</code> ha exportado las functiones <code>area()</code> y
<code>circumference()</code>.  Para exportar a un objeto, debe añadir el objeto especial
<code>exports</code>.</p>

<p>Las variables locales del módulo serán privadas. En este ejemplo la variable <code>PI</code> es
privada en <code>circle.js</code>.</p>

<h3 id="m_dulos_b_sicos">Módulos básicos</h3>

<p>Node posee varios módulos compilados en binario.  Estos módulos son
descritos con más detalle en las siguientes secciones del documento.</p>

<p>Los módulos básicos son definidos en el código fuente de node en la carpeta <code>lib/</code>.</p>

<p>Los módulos básicos tienen la preferencia de cargarse primero si su indentificador es
pasado desde <code>require()</code>. Por ejemplo, <code>require('http')</code> siempre
devolverá lo construido en el módulo HTTP, incluso si hay un fichero con ese nombre.</p>

<h3 id="m_dulo_File">Módulo File</h3>

<p>Si el nombre exacto del fichero no es encontrado, entonces node intentará cargar 
el nombre del fichero seguido de la extensión <code>.js</code>, y a continuación con <code>.node</code>.</p>

<p>Los ficheros <code>.js</code> son interpretados como ficheros de texto en JavaScript, y los ficheros <code>.node</code>
son interpretados como extensiones de módulos compilados cargados con <code>dlopen</code>.</p>

<p>Un módulo con el prefijo <code>'/'</code> indica la ruta absoluta al fichero.  Por
ejemplo, <code>require('/home/marco/foo.js')</code> cargará el fichero en
<code>/home/marco/foo.js</code>.</p>

<p>Un módulo con el prefijo <code>'./'</code> es relativo al fichero llamado con <code>require()</code>.
Es decir, <code>circle.js</code> debe estar en el mismo directorio que <code>foo.js</code> para que 
<code>require('./circle')</code> lo encuentre.</p>

<p>Si se omite el uso de '/' o './' en el fichero, el módulo puede ser un
"módulo básico" o se cargará desde la carpeta <code>node_modules</code>.</p>

<h3 id="cargando_desde_la_carpeta_node_modules_">Cargando desde la carpeta `node_modules`</h3>

<p>Si el identificador del módulo pasa a <code>require()</code> no es un módulo nativo,
y no comienza con <code>'/'</code>, <code>'../'</code>, o <code>'./'</code>, entonces node inicia en el 
directorio principal del módulo actual, y añade <code>/node_modules</code>, e
intenta cargar el módulo desde esa ubicación.</p>

<p>Si no se encuentra, entonces se dirige al directorio principal, y así 
sucesivamente, hasta que el módulo es encontrado, hasta en la raíz del árbol es
encontrado.</p>

<p>Por ejemplo, si el fichero en <code>'/home/ry/projects/foo.js'</code> es llamado como
<code>require('bar.js')</code>, entonces node buscaría en las siguientes ubicaciones, en
este orden:</p>

<ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul>

<p>Esto permite que los programas encuentren sus dependencias, de modo que no
entren en conflicto.</p>

<h4 id="optimizaci_n_de_proceso_de_b_squeda_en_node_modules_">Optimización de proceso de búsqueda en `node_modules`</h4>

<p>Cuando existen muchos niveles de dependencias anidadas, es posible que los
árboles de directorios tomen bastante tiempo. Las siguientes optimizaciones se
realizan para este proceso.</p>

<p>Primero, <code>/node_modules</code> no debe ser anexado a una carpeta ya que termina en
<code>/node_modules</code>.</p>

<p>Segundo, si el fichero es llamado con  <code>require()</code> ya esta en la jerarquía de
<code>node_modules</code>, entonces el nivel superior de la carpeta <code>node_modules</code> es tratada como
la raíz del árbol de búsqueda.</p>

<p>For example, if the file at
<code>'/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js'</code>
called <code>require('asdf.js')</code>, then node would search the following
locations:</p>

<p>Por ejemplo, si el fichero en
<code>'/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js'</code>
llama como <code>require('asdf.js')</code>, entonces node buscaría en las siguientes
ubicaciones:</p>

<ul><li><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</code></li><li><code>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</code></li><li><code>/home/ry/projects/foo/node_modules/asdf.js</code></li></ul>

<h3 id="carpetas_como_m_dulos">Carpetas como módulos</h3>

<p>Es conveniente organizar los programas y librerías en los mismos directorios,
y proporcionar un único punto de entrar a la biblioteca.
Existe tres formas en donde una carpeta pueda usar <code>require()</code> como
un argumento.</p>

<p>Lo primero es crear el fichero <code>package.json</code>en la raíz de la carpeta,
que especifique el módulo <code>main</code>. Un ejemplo de package.json podría verse
como esto:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }</code></pre>

<p>Si fuera una carpeta en <code>./some-library</code>, entonces
<code>require('./some-library')</code> trataría de cargar
<code>./some-library/lib/some-library.js</code>.</p>

<p>Este es el mayor grado de conciencia de Node con el fichero package.json .</p>

<p>Si no hay ningún fichero package.json presente en el directorio, entonces node
intentará cargar el fichero <code>index.js</code> o <code>index.node</code> de ese directorio.
Por ejemplo, si no hay ninguín fichero package.json en el ejemplo anterior,
entonces <code>require('./some-library')</code> intentará cargar:</p>

<ul><li><code>./some-library/index.js</code></li><li><code>./some-library/index.node</code></li></ul>

<h3 id="almacenamiento_en_la_cach_">Almacenamiento en la caché</h3>

<p>Los módulos se alamacenan en la caché después que fueron cargados por primera vez.
Esto significa (entre otras cosas) que todas las llamadas a <code>require('foo')</code> devuelve
el mismo ojecto exacto, si se resolvería en el mismo fichero</p>

<h3 id="todos_juntos...">Todos juntos...</h3>

<p>Para obtener el nombre exacto del fichero que se cargará cuando se llame con <code>require()</code>, use
la función <code>require.resolve()</code>.</p>

<p>Uniendo todo lo anterior, aquí se muestra un algoritmo de alto nievel
en pseudocódigo de lo que haría require.resolve :</p>

<pre><code>require(X)
1. Si X es módulo básico,
   a. devolver el módulo básico
   b. STOP
2. Si X inicia con con `./` or `/`,
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. Si X es un fichero, cargar X como texto JavaScript.  STOP
2. Si X.js es un fichero, cargar X.js como texto JavaScript.  STOP
3. Si X.node es un fichero, cargar X.node como extensión binaria.  STOP

LOAD_AS_DIRECTORY(X)
1. Si X/package.json es un fichero,
   a. Parsear X/package.json, y buscar el campo "main".
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. LOAD_AS_FILE(X/index)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index es una instancia de "node_modules" en PARTS, o 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
6. return DIRS</code></pre>

<h3 id="cargar_desde_las_carpetas_de_require.paths_">Cargar desde las carpetas de `require.paths`</h3>

<p>En node, <code>require.paths</code> es un array de strings que representa las rutas de
acceso a los módulos cuando estos no tienen el prefijo <code>'/'</code>, <code>'./'</code>, o
<code>'../'</code>.  Por ejemplo, si establece require.paths como:</p>

<pre><code>[ '/home/micheil/.node_modules',
  '/usr/local/lib/node_modules' ]</code></pre>

<p>A continuación se llama a <code>require('bar/baz.js')</code> y buscará en las siguientes
ubicaciones:</p>

<ul><li>1: <code>'/home/micheil/.node_modules/bar/baz.js'</code></li><li>2: <code>'/usr/local/lib/node_modules/bar/baz.js'</code></li></ul>

<p>El array en <code>require.paths</code> puede ser transformado en tiempo de ejecución para modificar
este comportamiento.</p>

<p>Se establece inicialmente la variable de entorno <code>NODE_PATH</code>, que contiene 
una lista delimitada por dos puntos de rutas exactas.  En el anterior ejemplo,
la variable de entorno <code>NODE_PATH</code> puedo haber sido establecido como:</p>

<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>

<p>Cargar las ubicaciones desde <code>require.paths</code> sólo se realiza si el
módulon no se ha encontrado desde el algoritmo <code>node_modules</code>.
Los módulos globarles son de baja prioridad para las dependencias de los paquetes.</p>

<h4 id="_Nota_Por_favor_evite_la_modificaci_n_de_require.paths_">**Nota:** Por favor evite la modificación de `require.paths`</h4>

<p>Por razones de compatibilidad, <code>require.paths</code> sigue siendo la primera prioridad
en el proceso de búsqueda de módulos. Sin embargo, puede desaparecer en una próxima
versión.</p>

<p>Aunque parecía una buena idea en aquel tiempo, y ha permitido ser un 
experimento muy útil, en la práctica la transformación de <code>require.paths</code> es una
lista a menudo con problemas y dolores de cabeza.</p>

<h5 id="establecer_require.paths_a_alg_n_otro_valor_para_nada.">Establecer `require.paths` a algún otro valor para nada.</h5>

<p>Esto no hace nada de lo que se podría esperar:</p>

<pre><code>require.paths = [ '/usr/lib/node' ];</code></pre>

<p>Todo lo que se hace aquí es perder la referencia <em>actual</em> de node en la búsqueda
de rutas, y crea una nueva referencia a otra cosa que no sirve
para nada.</p>

<h5 id="poner_rutas_relativas_en_require.paths_es..._raro.">Poner rutas relativas en `require.paths` es... raro.</h5>

<p>Si hace esto:</p>

<pre><code>require.paths.push('./lib');</code></pre>

<p>entonces <em>no</em> añada la ruta completa donde se resolvió <code>./lib</code>
en este sistema de ficheros.  En cambio, esto añade literalmente <code>'./lib'</code>,
lo que significa si hace <code>require('y.js')</code> en  <code>/a/b/x.js</code>, entonces se ve
en <code>/a/b/lib/y.js</code>.  Si a continuación se usa <code>require('y.js')</code> en
<code>/l/m/n/o/p.js</code>, entonces se ve en <code>/l/m/n/o/lib/y.js</code>.</p>

<p>En la práctica, las personas han usado esto de una manera ad hoc para la
dependencia de paquetes, pero esta técnica es frágil.</p>

<h5 id="cero_aislamiento">Cero aislamiento</h5>

<p>Existe (debido a un diseño lamentable), sólo un array <code>require.paths</code> utilizado para
todos los módulos.</p>

<p>Como resultado, si un programa en node trata de confiar de este comportamiento, es posible
que de manera permanente y sutilmente altere el comportamiento de todos los programas 
escritos en node el mismo proceso. A media que el stack crece, y se reune más
funcionalidades, ya que esto es un problema con las partes que interactúan en forma
difíciles de predecir.</p>

<h2 id="addenda_Consejos_para_administrar_paquetes">Addenda: Consejos para administrar paquetes</h2>

<p>La semántica de Node en la función <code>require()</code> fue diseñada para ser lo 
suficientemente general para soportar una serie de esctructuras de directorios.
Los paquetes de programas como <code>dpkg</code>, <code>rpm</code>, y <code>npm</code> se esperan que sean construidos 
como paquetes nativos desde los módulos de Node sin modificaciones.</p>

<p>A continuación sugerimos una estructura en la que puede trabajar:</p>

<p>Supongamos que se desea tener en 
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> se mantenga el contenido de una
versión específica de un paquete.</p>

<p>Los paquetes pueden depender uno del otro. Con el fin de instalar el paquete <code>foo</code>, 
puede que tenga que instalar una versión específica del paquete <code>bar</code>.  El paquete
 <code>bar</code> puede tener dependencias, y en algunos casos, estas dependencias, incluso pueden 
entrar en conflicto o crear ciclos.</p>

<p>Desde la búsqueda con Node de la <code>ruta</code> de cualquier módulo cargado (es decir,
resueltos los enlaces simbólicos), y luego de buscar sus dependencias en la
carpeta <code>node_modules</code> como se describió anteriormente, esta situación es muy simple de 
resolver con la siguiente arquitectura:</p>

<ul><li><code>/usr/lib/node/foo/1.2.3/</code> - Contenido del paquete <code>foo</code>, versión 1.2.3.</li><li><code>/usr/lib/node/bar/4.3.2/</code> - Contenido del paquete <code>bar</code> que es
dependencia de <code>foo</code>.</li><li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Enlace simbólico a
<code>/usr/lib/node/bar/4.3.2/</code>.</li><li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Enlaces simbólicos a los paquetes
que <code>bar</code> depende.</li></ul>

<p>Por lo tanto, incluso si se encuentra, o si hay problemas de dependencias,
cada módulo será capza de obtener una versión de su dependencia para ser
utilizada.</p>

<p>Cuando el código en el paquete <code>foo</code> utiliza <code>require('bar')</code>, se obtendrá la
versión al enlace simbólico en <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Luego, cuando el código del paquete <code>bar</code> llame a <code>require('quux')</code>, obtendrá
la versión simbólica en <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>

<p>Además, para hacer el proceso de búsqueda del módulo aún más óptima, en lugar
de poner los paquetes directamente en <code>/usr/lib/node</code>, se puede poner estos en
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Entonces node no se molestará en
buscar por dependencias no encontradas en <code>/usr/node_modules</code> o <code>/node_modules</code>.</p>

<p>A fin de que los módulos disponibles para node en REPL, puedan ser útiles,
añade también la carpeta <code>/usr/lib/node_modules</code> a la variable de entorno <code>$NODE_PATH</code>.
Desde el módulo de búsquedas usando la carpeta <code>node_modules</code> donde todo es
relativo, y basado en la ruta real de los ficheros llamados por <code>require()</code>, 
los paquetes pueden ser llamado desde cualquier lugar.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
</body>
</html>

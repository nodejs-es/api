<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>tls - Node.js Manual &amp; Documentación</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all"/>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js Manual &amp; Documentación</h1>
      <div id="gtoc">
        <p><a href="index.html">Inicio</a> | <a href="all.html">Ver en una página</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Tabla de contenidos</h2><ul><li><a href="#tLS_">TLS (SSL)</a><ul><li><a href="#s_tls.connect">s = tls.connect(port, [host], [options], callback)</a></li><li><a href="#tls.Server">tls.Server</a><ul><li><a href="#tls.createServer">tls.createServer(options, secureConnectionListener)</a></li><li><a href="#event_secureConnection_">Event: 'secureConnection'</a></li><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li></ul></li></ul></li></ul><hr /></div>
<h2 id="tLS_">TLS (SSL)</h2>

<p>Usa <code>require('tls')</code> para acceder a este módulo.</p>

<p>El módulo <code>tls</code> utiliza OpenSSL para proveer seguridad en la Transport Layer Security y/o Secure Socket Layer: encriptacion de flujo de comunicaciones.</p>

<p>TLS/SSL es una infraestructura de clave publica/privada. Cada cliente y cada servidor deben tener una clave privada. Una clave privada se crea como sigue:</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>

<p>Todos los servidores y algunos clientes necesitan tener un certificado. Los certificados son claves públicas firmadas por una autoridad certificadora (CA) o por ellas mismas. El primer paso para obtener un certificado es crear un fichero de "Petición de firma de Certificado" (CSR). Esto se hace como sigue:</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>

<p>Para crear un certificado auto firmado con el CSR, hay que hacer:</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>

<p>De forma alternativa puedes enviar el CSR a la autoridad certificadora para firmarlo.</p>

<p>(TODO: documentos sobre la creación de una CA, por ahora los usuarios interesados deberían echar un vistazo a <code>test/fixtures/keys/Makefile</code> en el código fuente de Node)</p>

<h3 id="s_tls.connect">s = tls.connect(port, [host], [options], callback)</h3>

<p>Crea una nueva conexión cliente al <code>port</code> y al <code>host</code> dados. (<code>host</code> por defecto es <code>localhost</code>.) <code>options</code> debe ser un objeto que especifique:</p>

<ul><li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la llave privada del servidor en formato PEM. (Requerido)</p></li><li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene la clave del certificado del servidor en formato PEM.</p></li><li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs "root" bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p></li></ul>

<p><code>tls.connect()</code> devuelve un objeto <code>CryptoStream</code> en texto plano.</p>

<p>Después del TSL/SSL handshake el <code>callback</code> es invocado. El <code>callback</code> será invocado independientemente si el certificado del servidor fue autorizado o no. Es responsabilidad del usuario probar <code>s.authorized</code> para ver si el certificado del servidor estaba firmado por una de las CAs especificadas. Si <code>s.authorized === false</code> entonces el error puede encontrarse en <code>s.authorizationError</code>.</p>

<h3 id="tls.Server">tls.Server</h3>

<p>Esta clase es una subclase de <code>net.Server</code> y tiene los mismos métodos.
En lugar de aceptar solo conexiones TCP en bruto, acepta conexiones encriptadas usando TLS o SSL.</p>

<p>Aquí hay un ejemplo simple de un servidor eco:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
};

tls.createServer(options, function (s) {
  s.write("welcome!\n");
  s.pipe(s);
}).listen(8000);</code></pre>

<p>Puedes probar este servidor conectándose a él con <code>openssl s_client</code>:</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>

<h4 id="tls.createServer">tls.createServer(options, secureConnectionListener)</h4>

<p>Este es un constructor para la clase <code>tls.Server</code>. El objeto options puede contener:</p>

<ul><li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la clave privada del servidor en formato PEM. (Requerido)</p></li><li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene el certificado del servidor en formato PEM. (Requerido)</p></li><li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs "root" bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p></li><li><p><code>requestCert</code>: Si es <code>true</code> el servidor solicitará un certificado de todos los clientes que se conecten e intenten verificar ese certificado. Por defecto: <code>false</code></p></li><li><p><code>rejectUnauthorized</code>: Si es <code>true</code> el servidor rechazará cualquier conexión no autorizada por la lista de CAs suministradas. Esta opción solo tiene efecto si <code>requestCert</code> es <code>true</code>. Por defecto: <code>false</code>.</p></li></ul>

<h4 id="event_secureConnection_">Event: 'secureConnection'</h4>

<p><code>function (cleartextStream) {}</code></p>

<p>Este evento es emitido después de que una nueva conexión haya realizado con éxito el handshake. El argumento es una instancia de <code>stream.Stream</code>. Tiene todos los métodos y eventos de stream.</p>

<p><code>cleartextStream.authorized</code> es un valor boolean que indica si el cliente está verificado por una de las CA suministradas por el servidor. Si <code>cleartextStream.authorized</code> es false, entonces <code>cleartextStream.authorizationError</code> describe como falló la autorización. Relacionado pero merece mencionarse: dependiendo de la configuración del servidor TLS, tus autorizaciones de conexión pueden ser aceptadas.</p>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Empieza aceptando conexiones en el <code>port</code> y el <code>host</code> especificados. Si el <code>host</code> es omitido, el servidor aceptará conexiones dirigidas a cualquier dirección IPv4 (<code>INADDR_ANY</code>).</p>

<p>Esta función es asíncrona. El último parámetro <code>callback</code> se invocará cuando el servidor esté saturado.</p>

<p>Mirar <code>net.Server</code> para más información.</p>

<h4 id="server.close">server.close()</h4>

<p>Detiene el servidor, dejando de aceptar conexiones. Esta función es asíncrona, el servidor finalmente se cierra cuando emite un evento <code>'close'</code>.</p>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Establece esta propiedad para rechazar conexiones cuando el número de conexiones del servidor sea alta.</p>

<h4 id="server.connections">server.connections</h4>

<p>Número de conexiones concurrentes en el servidor.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
</body>
</html>
